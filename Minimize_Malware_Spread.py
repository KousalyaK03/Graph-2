class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        Approach:
        - Treat the network as an undirected graph.
        - Use DFS to find connected components and assign component IDs to nodes.
        - Count the size of each connected component.
        - For each component, count how many infected nodes are present in it.
        - If a component has exactly one infected node, removing that node will isolate the component and minimize the spread.
        - If multiple nodes have the same impact, return the node with the smallest index.
        Time Complexity: O(n^2) - for traversing the adjacency matrix.
        Space Complexity: O(n) - for storing component details.
        """

        def dfs(node, comp_id):
            """Perform DFS to mark all nodes in the same component."""
            component_map[node] = comp_id
            component_size[comp_id] += 1
            for neighbor in range(n):
                if graph[node][neighbor] == 1 and neighbor not in component_map:
                    dfs(neighbor, comp_id)

        n = len(graph)
        component_map = {}  # Maps each node to its component ID
        component_size = []  # Stores the size of each component
        component_infected_count = {}  # Tracks the number of infected nodes in each component

        # Step 1: Identify connected components
        component_id = 0
        for i in range(n):
            if i not in component_map:
                component_size.append(0)  # Initialize size for this new component
                dfs(i, component_id)
                component_id += 1

        # Step 2: Count infected nodes in each component
        for node in initial:
            comp_id = component_map[node]
            if comp_id not in component_infected_count:
                component_infected_count[comp_id] = 0
            component_infected_count[comp_id] += 1

        # Step 3: Determine the best node to remove
        result = float('inf')
        max_saved = 0  # Maximum number of nodes we can save by removing a node

        # Sort initial to ensure lexicographical order in case of ties
        initial.sort()

        for node in initial:
            comp_id = component_map[node]
            if component_infected_count[comp_id] == 1:  # Unique infected node in this component
                if component_size[comp_id] > max_saved:
                    max_saved = component_size[comp_id]
                    result = node
                elif component_size[comp_id] == max_saved:
                    result = min(result, node)

        # If no unique infected nodes, return the smallest index
        return result if result != float('inf') else min(initial)
